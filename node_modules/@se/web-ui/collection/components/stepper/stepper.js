import { Component, Element, h, Listen, State, Prop, Method } from "@stencil/core";
export class StepperComponent {
    constructor() {
        this.stepperItems = [];
        /**
         * Sets the background color of your stepper.
         * The default setting is `primary`, implementing a green background for the stepper visual items.
         * The `alternative` setting implements a white background for the stepper visual items.  This setting is best used against a gray background.
         */
        this.color = 'primary';
        /**
         * Defines if the stepper items must be completed sequentially.
         * The default setting is `true`, each stepper item must be validated before advancing to the next step.
         * `false` allows each step to be selected in any order.
         */
        this.linear = true;
    }
    /**
     * Call the `reset` method to reset the stepper to the indicated step.  This also invalidates any validated steps.
     * It no step parameter is provided, it will reset to the first stepper item.
     */
    async reset(step = 1) {
        if (step >= this.getItemStep(this.selectedItem)) {
            return; // don't advance the stepper when clicking the reset button
        }
        this.stepperItems.forEach((item) => {
            if (this.getItemStep(item) >= step) {
                item.validated = false;
            }
        });
        this.selectStep(this.stepperItems[step - 1]);
    }
    /**
     * Call the `previous` method to navigate to the previous step from the step that is currently selected.
     */
    async previous() {
        // do not trigger this method when the first stepper item is the active item
        if (this.getItemStep(this.selectedItem) > 1) {
            const index = this.stepperItems.indexOf(this.selectedItem);
            this.selectStep(this.stepperItems[index - 1]);
        }
    }
    /**
     * Call the `next` method to navigate to the next step from the step that is currently selected.
     * This will not work in linear mode if the next step is not validated.
     */
    async next(validate) {
        if (validate) {
            this.selectedItem.validated = true;
        }
        if (!this.linear || this.selectedItem.validated) {
            const index = this.stepperItems.indexOf(this.selectedItem);
            this.selectStep(this.stepperItems[index + 1]);
        }
    }
    selectStep(item) {
        this.selectedItem.active = false;
        this.selectedItem = item;
        this.selectedItem.active = true;
    }
    itemValidated(value) {
        this.validatedChanged = value;
    }
    getItemStep(item) {
        return this.stepperItems.indexOf(item) + 1;
    }
    checkIfPreviousItemValidated(item) {
        if (this.getItemStep(item) > 1 && this.linear) {
            return !this.stepperItems[this.stepperItems.indexOf(item) - 1].validated;
        }
        return false;
    }
    renderList() {
        return this.stepperItems.map((item) => {
            return [
                h("li", { class: ["stepper-item-wrapper", (this.getItemStep(this.selectedItem) === this.getItemStep(item) || item.validated) ? "selected" : ''].join(' ') },
                    h("div", { class: ["stepper-item", this.checkIfPreviousItemValidated(item) ? "disabled" : ''].join(' '), onClick: () => this.selectStep(item) },
                        h("span", { class: ["indicator", item.validated && !item.active ? "se-icon" : ''].join(' ') }, this.getItemStep(item)),
                        h("span", { class: "stepper-item-label" }, item.label)),
                    this.getItemStep(item) !== this.stepperItems.length ? h("se-divider", null) : '')
            ];
        });
    }
    componentDidLoad() {
        this.stepperItems = Array.from(this.el.querySelectorAll('se-stepper-item'));
        this.stepperItems.forEach((item) => {
            if (this.linear && !item.validated) {
                item.validated = false;
            }
        });
        this.selectedItem = this.stepperItems[0];
        this.selectedItem.active = true;
    }
    render() {
        return [
            h("nav", { class: this.color },
                h("ol", null, this.renderList())),
            h("slot", null)
        ];
    }
    static get is() { return "se-stepper"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() { return {
        "$": ["stepper.scss"]
    }; }
    static get styleUrls() { return {
        "$": ["stepper.css"]
    }; }
    static get properties() { return {
        "color": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "'primary' | 'alternative'",
                "resolved": "\"alternative\" | \"primary\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Sets the background color of your stepper.\nThe default setting is `primary`, implementing a green background for the stepper visual items.\nThe `alternative` setting implements a white background for the stepper visual items.  This setting is best used against a gray background."
            },
            "attribute": "color",
            "reflect": false,
            "defaultValue": "'primary'"
        },
        "linear": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Defines if the stepper items must be completed sequentially.\nThe default setting is `true`, each stepper item must be validated before advancing to the next step.\n`false` allows each step to be selected in any order."
            },
            "attribute": "linear",
            "reflect": false,
            "defaultValue": "true"
        }
    }; }
    static get states() { return {
        "stepperItems": {},
        "selectedItem": {},
        "validatedChanged": {}
    }; }
    static get methods() { return {
        "reset": {
            "complexType": {
                "signature": "(step?: number) => Promise<void>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    },
                    "HTMLSeStepperItemElement": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Call the `reset` method to reset the stepper to the indicated step.  This also invalidates any validated steps.\nIt no step parameter is provided, it will reset to the first stepper item.",
                "tags": []
            }
        },
        "previous": {
            "complexType": {
                "signature": "() => Promise<void>",
                "parameters": [],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Call the `previous` method to navigate to the previous step from the step that is currently selected.",
                "tags": []
            }
        },
        "next": {
            "complexType": {
                "signature": "(validate: boolean) => Promise<void>",
                "parameters": [{
                        "tags": [],
                        "text": ""
                    }],
                "references": {
                    "Promise": {
                        "location": "global"
                    }
                },
                "return": "Promise<void>"
            },
            "docs": {
                "text": "Call the `next` method to navigate to the next step from the step that is currently selected.\nThis will not work in linear mode if the next step is not validated.",
                "tags": []
            }
        }
    }; }
    static get elementRef() { return "el"; }
    static get listeners() { return [{
            "name": "didValidate",
            "method": "itemValidated",
            "target": undefined,
            "capture": false,
            "passive": false
        }]; }
}
